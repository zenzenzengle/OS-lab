#!/usr/bin/perl -w

# Generate usys.S, the stubs for syscalls.
# 该脚本文件会在编译期间被执行，生成一个汇编文件usys.S。
# 其对每一个系统调用抽象接口都生成了一个具体的实现，叫做entry

print "# generated by usys.pl - do not edit\n";

print "#include \"kernel/syscall.h\"\n";

#这段脚本中的print的内容实际就是RISC-V指令集的汇编语言。
#$name就是系统调用的名字，如fork，exit等
#当脚本执行时，25行之后entry的内字符串会被填入$name。

sub entry {
    my $name = shift;
    print ".global $name\n";
    print "${name}:\n";

    #将系统调用号 SYS_${name}（来自kernel/syscall.h）传给RISC-V CPU上的a7寄存器，
    #这样内核就可以通过a7寄存器知道现在要处理的是什么系统调用。
    print " li a7, SYS_${name}\n";

    #特殊指令，用来转入操作系统内核（关键指令）
    print " ecall\n";

    #操作系统内核执行完后会返回到这里，
    #执行ret就结束了用户看到的系统调用，返回至用户程序。
    print " ret\n";
}
	

#定义一个系统调用实际上很简单：
#将系统调用号的宏定义SYS_${name}添加在kernel/syscall.h，
#每次系统调用时根据a7寄存器传入的值判定具体的系统调用类型即可。 
#那么接下来我们面临的第一个问题是：
#内核怎么通过系统调用号（存在寄存器a7里）来执行不同的系统调用函数？
#提示：关注kernel/syscall.c中的代码

entry("fork");
entry("exit");
entry("wait");
entry("pipe");
entry("read");
entry("write");
entry("close");
entry("kill");
entry("exec");
entry("open");
entry("mknod");
entry("unlink");
entry("fstat");
entry("link");
entry("mkdir");
entry("chdir");
entry("dup");
entry("getpid");
entry("sbrk");
entry("sleep");
entry("uptime");
entry("trace");
entry("sysinfo");